<!--
CURSOR INSTRUCTIONS:
===================

This is a wave-based defense game called "Penguin Wars: Defend the Ice" where you launch penguins to stop boats and sailors from invading your ice territory.

Game Structure:
--------------
1. HTML Structure:
   - #game-container: Main container for the entire game
   - #game-area: The playable area containing all game elements
   - #ground: The white ice surface at the bottom
   - #sea: The blue water area where enemies come from
   - #slingshot: The launcher for the penguin
   - #penguin: The player character (üêß)
   - .enemy: The invaders (boats and sailors - üö¢üßçüèª‚Äç‚ôÇÔ∏è)

2. Key Game Mechanics:
   - Drag the penguin back on the slingshot and release to launch
   - Physics simulation includes gravity, bounce, and friction
   - Hit the boats/sailors to prevent them from reaching your base
   - Enemies move from right to left across the screen
   - Game tracks waves of enemies and base health
   - Game ends when base health reaches zero

3. Key JavaScript Functions:
   - initGame(): Sets up the game environment and event listeners
   - startDrag(), onDrag(), endDrag(): Handle penguin launching
   - updatePhysics(): Handles the physics simulation and collisions
   - resetPenguin(): Resets the penguin to the slingshot
   - spawnEnemyWave(): Creates a new wave of enemies
   - updateEnemies(): Moves enemies across the screen
   - checkBaseCollisions(): Checks if enemies have reached the base
   - restartGame(): Resets the entire game state

4. Mobile Optimization:
   - Touch events are supported for mobile play
   - Viewport settings prevent unwanted zooming
   - Special handling for iOS Safari 100vh issue

5. Debug Features:
   - Toggle debug panel with the debug button
   - Shows position, velocity, and game state information

To modify the game:
- Change the emoji in the HTML to alter characters
- Adjust physics constants (GRAVITY, BOUNCE_FACTOR, etc.) for different feel
- Modify pig positions in createPigs() to change level layout
- Edit CSS for visual changes to game elements
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Penguin Wars: Defend the Sea</title>
    <!-- Use static favicon as default -->
    <link id="favicon" rel="icon" href="/favicons/penguin-right-favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Helvetica Neue', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #87CEEB;
            height: 100%;
            position: fixed;
            width: 100%;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            overflow: hidden;
        }
        
        #game-area {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #4682B4; /* Steel blue for sea */
            overflow: hidden;
        }
        
        #ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 20%;
            background-color: white;
        }
        
        /* Rename grass to sea - this is the boundary between sea and ice */
        #sea {
            position: absolute;
            bottom: 20%;
            width: 100%;
            height: 5%;
            background-color: #87CEEB; /* Light blue for sea surface */
            border-bottom: 2px solid #B0E0E6; /* Light blue border */
        }
        
        /* Base structure on the left side */
        #base {
            position: absolute;
            left: 0;
            bottom: 20%;
            width: 2%;
            height: 30%;
            background-color: #F0F8FF; /* Alice blue for ice structure */
            border-right: 4px solid #E0FFFF; /* Light cyan border */
            z-index: 2;
        }
        
        /* Health bar container */
        #health-container {
            width: 200px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 5px;
            z-index: 10;
        }
        
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #32CD32; /* Lime green */
            border-radius: 10px;
            transition: width 0.3s ease-in-out;
        }
        
        /* Wave counter */
        #wave-container {
            padding: 5px 15px;
            background-color: rgba(0, 0, 0, 0.3);
            color: white;
            border-radius: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 10;
        }
        
        #slingshot {
            position: absolute;
            left: 25%;
            bottom: 25%;
            width: 15px;
            height: 100px;
            background-color: #8B4513;
            border-radius: 5px 5px 7px 7px;
            z-index: 2;
            transform: translateY(10px);
        }
        
        #slingshot-band-left, #slingshot-band-right {
            position: absolute;
            width: 5px;
            height: 60px;
            background-color: #A52A2A;
            transform-origin: 50% 0;
            z-index: 1;
        }
        
        #slingshot-band-left {
            left: 0;
            top: 0;
            transform-origin: 0 0;
        }
        
        #slingshot-band-right {
            right: 0;
            top: 0;
            transform-origin: 100% 0;
        }
        
        #penguin {
            position: absolute;
            font-size: 40px;
            user-select: none;
            -webkit-user-select: none;
            z-index: 3;
            transition: transform 0.1s;
        }
        
        .face-right {
            transform: scaleX(-1);
        }
        
        .enemy {
            position: absolute;
            font-size: 35px;
            user-select: none;
            -webkit-user-select: none;
            z-index: 2;
            transition: transform 0.2s ease-in-out;
        }
        
        .pig {
            position: absolute;
            font-size: 52.5px;
            user-select: none;
            -webkit-user-select: none;
            z-index: 2;
            transform-origin: center center;
        }
        
        .explosion {
            position: absolute;
            font-size: 50px;
            user-select: none;
            -webkit-user-select: none;
            z-index: 4;
            opacity: 0;
            transform: scale(0.5) rotate(0deg);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                        opacity 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: drop-shadow(0 0 10px rgba(255, 200, 0, 0.8));
        }
        
        .explosion.active {
            opacity: 1;
            transform: scale(1.8) rotate(15deg);
        }

        .game-top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            gap: 10px;
            pointer-events: none;
            padding: 10px;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .game-stats {
            display: flex;
            flex-direction: column;
            align-items: end;
            gap: 10px;
        }
        
        #score-container {
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            color: #ff4500;
            text-shadow: 2px 2px 0 #ffb700;
            font-size: 2rem;
            font-weight: bold;
        }
        
        #restart-button {
            padding: 0 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            font-size: 2rem;
            background-color: transparent;
        }

        #restart-button:active {
            transform: translateY(2px) scale(0.98); 
        }
        
        #instructions {
            position: absolute;
            bottom: 70px;
            left: 20px;
            max-width: 400px;
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 10;
        }
        
        #debug-toggle {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            z-index: 10;
        }
        
        #debug-panel {
            position: absolute;
            bottom: 50px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            display: none;
            z-index: 10;
            max-width: 300px;
            max-height: 200px;
            overflow: auto;
        }
        
        #touch-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 2px solid #ff4500;
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
            display: none;
            transform: translate(-50%, -50%);
        }
        
        @keyframes shake {
            0% { transform: translate(0, 0); }
            10% { transform: translate(-5px, -5px); }
            20% { transform: translate(5px, 5px); }
            30% { transform: translate(-5px, 5px); }
            40% { transform: translate(5px, -5px); }
            50% { transform: translate(-5px, 0); }
            60% { transform: translate(5px, 0); }
            70% { transform: translate(0, 5px); }
            80% { transform: translate(0, -5px); }
            90% { transform: translate(-2px, 2px); }
            100% { transform: translate(0, 0); }
        }
        
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        
        #waiting-penguin {
            position: absolute;
            font-size: 35px;
            left: 15%;
            bottom: 25%;
            user-select: none;
            -webkit-user-select: none;
            z-index: 2;
        }
        
        @keyframes jump {
            0%, 15%, 30%, 45%, 60%, 75%, 100% { transform: translateY(0); }
            7.5% { transform: translateY(-15px); }
            22.5% { transform: translateY(-10px); }
            37.5% { transform: translateY(-20px); }
            52.5% { transform: translateY(-8px); }
            67.5% { transform: translateY(-12px); }
        }
        
        .jumping {
            animation: jump 4s ease-in-out infinite;
        }
        
        /* Animation for the penguin in the slingshot */
        @keyframes slingshot-penguin-animation {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-5px) rotate(-3deg); }
            50% { transform: translateY(0) rotate(0deg); }
            75% { transform: translateY(-3px) rotate(3deg); }
        }
        
        .slingshot-penguin-animate {
            animation: slingshot-penguin-animation 3s ease-in-out infinite;
        }
        
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
            pointer-events: auto; /* Ensure clicks work on the overlay */
        }
        
        #game-over-content {
            padding: 20px;
            text-align: center;
            max-width: 80%;
            color: wheat;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border-radius: 15px;
        }
        
        #final-score {
            font-size: 5rem;
            color: #ff4500;
            text-shadow: 2px 2px 0 #ffb700;
            font-weight: bold;
            line-height: 1;
        }

        .final-score-title {
            font-weight: bold;
            color: wheat;
            margin-bottom: 5px;
        }
        
        .final-wave-title {
            font-weight: bold;
            color: wheat;
            margin-top: 15px;
            margin-bottom: 5px;
        }
        
        #final-wave {
            font-size: 3rem;
            color: #4682B4;
            text-shadow: 2px 2px 0 #87CEEB;
            font-weight: bold;
            line-height: 1;
        }
        
        #play-again-button {
            padding: 15px 30px;
            background-color: #ffb700;
            color: #924e0f;
            border: none;
            border-radius: 5px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
        }
        
        #play-again-button:hover {
            background-color: #ff9500;
        }
        
        #level-display-container {
            padding: 10px 15px;
            background-color: rgba(255, 183, 0, 0.8);
            color: #924e0f;
            border-radius: 5px;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 10;
            text-align: center;
        }
        
        @keyframes levelUp {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.3); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        .level-up-animation {
            animation: levelUp 0.5s ease-in-out;
        }
        
        /* Wave transition animation */
        @keyframes waveTransition {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.2); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        .wave-transition {
            animation: waveTransition 1s ease-in-out;
        }
        
        /* Base damage animation */
        @keyframes baseDamage {
            0% { background-color: #F0F8FF; }
            50% { background-color: #FF4500; }
            100% { background-color: #F0F8FF; }
        }
        
        .base-damage {
            animation: baseDamage 0.5s ease-in-out;
        }

        /* Add CSS for pause button and overlay right after the game-over-overlay CSS */
        #pause-button {
            padding: 0 10px;
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            font-size: 2rem;
            font-weight: bold;
        }

        #pause-button:active {
            transform: scale(0.98);
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99;
        }

        #pause-message {
            font-size: 3rem;
            color: white;
            text-shadow: 2px 2px 0 #4682B4;
            margin-bottom: 20px;
        }

        #resume-button {
            background-color: #4682B4;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
        }

        #resume-button:hover {
            background-color: #5692C4;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-area">
            <div id="sea"></div>
            <div id="ground"></div>
            <div id="base"></div>
            <div id="slingshot">
                <div id="slingshot-band-left"></div>
                <div id="slingshot-band-right"></div>
            </div>
            <div id="penguin">
                <div class="face-right js-penguin-emoji">üêß</div>
            </div>
            <div id="waiting-penguin" class="jumping">
                <div class="face-right js-penguin-emoji">üêß</div>
            </div>
            <div id="touch-marker"></div>
        </div>
        <div class="game-top-bar">
            <div class="game-controls">
                <button id="restart-button">üîÑ</button>
                <button id="pause-button">‚è∏Ô∏è</button>
            </div>
        <div class="game-stats">
            <div id="score-container"><span id="score">0</span></div>
            <div id="health-container"><div id="health-bar"></div></div>
            <div id="wave-container">Wave: <span id="wave-number">1</span></div>
        </div>

    </div>

        <div id="instructions">
            Drag the penguin back, then release to launch!<br>
            Stop the sea invaders before they reach your base.<br>
            Your base has 100 health. Each enemy that reaches it deals 10 damage.
        </div>
        
        <!-- Pause overlay -->
        <div id="pause-overlay">
            <div id="pause-message">Game Paused</div>
            <button id="resume-button">Resume</button>
        </div>
        
        <button id="debug-toggle">Show Debug</button>
        <div id="debug-panel"></div>
        
        <!-- Level display -->
        <div id="level-display-container">
            <div id="level-display">Level 1</div>
        </div>
        
        <!-- Game over overlay -->
        <div id="game-over-overlay">
            <div id="game-over-content">
                <header>
                    <h1>Game Over!</h1>
                    <p>The sea base has been overrun</p>
                </header>
                <section>
                    <p class="final-score-title">Score</p>
                    <div id="final-score">0</div>
                    <p class="final-wave-title">Wave</p>
                    <div id="final-wave">1</div>
                </section>
                <button id="play-again-button">Play Again</button>
            </div>
        </div>
        
        <!-- Audio elements for sound effects -->
        <audio id="explosion-sound-1" src="https://assets.mixkit.co/active_storage/sfx/212/212-preview.mp3" preload="auto"></audio>
        <audio id="explosion-sound-2" src="https://assets.mixkit.co/active_storage/sfx/235/235-preview.mp3" preload="auto"></audio>
    </div>

    <script>
        // Fix for iOS Safari 100vh viewport issue
        function setViewportHeight() {
            let vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        
        // Initial setup
        setViewportHeight();
        window.addEventListener('resize', function() {
            setViewportHeight();
            if (!isPenguinLaunched) {
                resetPositions();
            }
        });
        
        // Game initialization
        document.addEventListener('DOMContentLoaded', initGame);
        window.addEventListener('load', initGame); // Additional initialization on full load
        
        // Global variables
        let penguin;
        let waitingPenguin;
        let slingshot;
        let slingshotBandLeft;
        let slingshotBandRight;
        let enemies = []; // Renamed from pigs to enemies
        let score = 0;
        let isPenguinLaunched = false;
        let isDragging = false;
        let initialPenguinPos = { x: 0, y: 0 };
        let restPosition = { x: 0, y: 0 };
        let dragStartPos = { x: 0, y: 0 };
        let currentPos = { x: 0, y: 0 };
        let velocity = { x: 0, y: 0 };
        let penguinLastTimestamp = 0; // Separate timestamp for penguin physics
        let gameLastTimestamp = 0; // Separate timestamp for game updates
        let animationFrameId = null;
        let gameAnimationFrameId = null; // Separate animation frame ID for game updates
        let debugMode = false;
        let touchMarker;
        let baseHealth = 100; // Base health
        let currentWave = 1; // Current wave number
        let enemiesInWave = 7; // Number of enemies in current wave
        let waveInProgress = false; // Flag to track if a wave is in progress
        let enemySpawnInterval = null; // Interval for spawning enemies
        let enemySpeed = 0.7; // Base speed for enemies - increased from 0.5 to 0.7
        let gameOver = false;
        let gameEnding = false; // Flag to indicate the game is ending but not yet over
        let faviconLink; // Link element for favicon
        let slowMovementTime = 0; // Track how long the penguin has been moving slowly
        let MAX_SLOW_MOVEMENT_TIME = 1000; // Reduced from 2000ms to 1000ms to reset slow penguins faster
        let gamePaused = false; // Flag to track if the game is paused
        
        // Physics constants
        const GRAVITY = 0.5;
        const BOUNCE_FACTOR = 0.7;
        const FRICTION = 0.98;
        const PENGUIN_RADIUS = 20;
        const ENEMY_RADIUS = 17.5; // Renamed from PIG_RADIUS
        const ELASTICITY = 8; // Reduced from 10 to 8 for more powerful launches
        const MIN_EXPLOSION_SPEED = 8; // Minimum speed required for enemies to explode
        const BASE_DAMAGE_PER_ENEMY = 10; // Damage each enemy deals to the base
        
        // Level generation constants
        const TARGET_TYPES = [
            { emoji: 'üö¢', name: 'cargo ship', points: 100, size: 1.5 },
            { emoji: '‚õµ', name: 'sailboat', points: 120, size: 1.3 },
            { emoji: 'üõ•Ô∏è', name: 'speedboat', points: 150, size: 1.4 },
            { emoji: 'ü¶≠', name: 'seal', points: 180, size: 1.0 },
            { emoji: 'ü¶à', name: 'shark', points: 250, size: 1.6 },
            { emoji: 'üèä‚Äç‚ôÇÔ∏è', name: 'swimmer', points: 200, size: 0.9 }
        ];
        
        const FORMATIONS = [
            'standard',    // Scattered targets
            'pyramid',     // Pyramid formation
            'wall',        // Wall formation
            'floating',    // Targets at different heights
            'random'       // Completely random positions
        ];
        
        const DIFFICULTY_LEVELS = [
            { name: 'easy', targetCount: { min: 3, max: 5 }, speedFactor: 1.0 },
            { name: 'medium', targetCount: { min: 4, max: 7 }, speedFactor: 1.2 },
            { name: 'hard', targetCount: { min: 6, max: 9 }, speedFactor: 1.5 }
        ];
        
        // Current level settings
        let currentDifficulty = 0; // 0: easy, 1: medium, 2: hard
        let currentLevel = 1;
        
        // Function to set favicon using static files
        function setFavicon(type) {
            const favicon = document.getElementById('favicon');
            
            if (type === 'explosion') {
                favicon.href = '/favicons/explosion-favicon.png';
            } else if (type === 'right') {
                favicon.href = '/favicons/penguin-right-favicon.png';
            } else if (type === 'left') {
                favicon.href = '/favicons/penguin-left-favicon.png';
            }
        }
        
        // Function to update favicon based on penguin direction
        function updateFaviconDirection() {
            // Check if explosion is active
            if (document.getElementById('favicon').dataset.explosionActive === 'true') {
                return; // Don't update direction during explosion
            }
            const penguinEmoji = penguin.querySelector('.js-penguin-emoji');
            // Determine if penguin is facing right based on class
            const isFacingRight = penguinEmoji.classList.contains('face-right');
            setFavicon(isFacingRight ? 'right' : 'left');
        }
        
        function initGame() {
            // Get DOM elements
            penguin = document.getElementById('penguin');
            waitingPenguin = document.getElementById('waiting-penguin');
            slingshot = document.getElementById('slingshot');
            slingshotBandLeft = document.getElementById('slingshot-band-left');
            slingshotBandRight = document.getElementById('slingshot-band-right');
            touchMarker = document.getElementById('touch-marker');
            
            // Set initial penguin favicon - initially facing right
            setFavicon('right');
            
            // Set initial position for penguin - position it precisely at the top center of the slingshot
            const slingshotRect = slingshot.getBoundingClientRect();
            restPosition = {
                x: slingshotRect.left + (slingshotRect.width / 2) - (penguin.offsetWidth / 2),
                y: slingshotRect.top - penguin.offsetHeight + 10 // Add a small overlap to make it look like it's on the slingshot
            };
            
            // Make sure the waiting penguin's span has the correct transform
            const waitingPenguinDiv = waitingPenguin.querySelector('.js-penguin-emoji');
            if (waitingPenguinDiv) {
                waitingPenguinDiv.classList.add('face-right');
            } else {
                // If the span doesn't exist for some reason, recreate it
                waitingPenguin.innerHTML = '<div class="face-right js-penguin-emoji">üêß</div>';
            }
            
            // Apply random animation delay to waiting penguin
            applyRandomJumpDelay();
            
            // Reset game state
            resetPenguin();
            resetGameState();
            
            // Add event listeners for mouse/touch
            penguin.addEventListener('mousedown', startDrag, { passive: false });
            penguin.addEventListener('touchstart', startDrag, { passive: false });
            
            // Add global event listeners for mouse/touch release
            // This ensures the penguin is launched even if the mouse is released outside the penguin element
            document.addEventListener('mouseup', (e) => {
                console.log("mouseup event");
                if (isDragging) {
                    endDrag(e);
                }
            });
            
            document.addEventListener('touchend', (e) => {
                console.log("touchend event");
                if (isDragging) {
                    endDrag(e);
                }
            });
            
            // Add event listener for restart button
            document.getElementById('restart-button').addEventListener('click', restartGame);
            
            // Add event listener for play again button
            document.getElementById('play-again-button').addEventListener('click', restartGame);
            
            // Add event listeners for pause and resume buttons
            document.getElementById('pause-button').addEventListener('click', pauseGame);
            document.getElementById('resume-button').addEventListener('click', resumeGame);
            
            // Add event listener for debug toggle
            document.getElementById('debug-toggle').addEventListener('click', toggleDebug);
            
            // Start debug info updates
            updateDebugInfo();
            
            // Start the first wave
            startNextWave();
        }
        
        function resetGameState() {
            // Reset game variables
            score = 0;
            baseHealth = 100;
            currentWave = 1;
            enemiesInWave = 7; // Updated to match our new base enemy count
            waveInProgress = false;
            gameOver = false;
            gameEnding = false;
            
            // Clear any existing enemies
            clearEnemies();
            
            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('wave-number').textContent = currentWave;
            document.getElementById('health-bar').style.width = '100%';
            document.getElementById('game-over-overlay').style.display = 'none';
            
            // Clear any existing spawn intervals
            if (enemySpawnInterval) {
                clearInterval(enemySpawnInterval);
                enemySpawnInterval = null;
            }
        }
        
        function clearEnemies() {
            // Remove all enemy elements from the DOM
            enemies.forEach(enemy => {
                if (enemy.element && enemy.element.parentNode) {
                    enemy.element.parentNode.removeChild(enemy.element);
                }
            });
            enemies = [];
            
            // Stop the game animation loop when clearing enemies
            if (gameAnimationFrameId) {
                cancelAnimationFrame(gameAnimationFrameId);
                gameAnimationFrameId = null;
            }
        }
        
        function startDrag(e) {
            e.preventDefault();
            
            if (isPenguinLaunched || gameOver) return;
            
            console.log("startDrag called");
            
            isDragging = true;
            const penguinRect = penguin.getBoundingClientRect();
            dragStartPos = {
                x: penguinRect.left + penguinRect.width / 2,
                y: penguinRect.top + penguinRect.height / 2
            };
            
            // Remove the animation class when dragging starts
            penguin.classList.remove('slingshot-penguin-animate');
            
            // Set initial penguin position for elastic calculations
            initialPenguinPos = {
                x: parseInt(penguin.style.left) || restPosition.x,
                y: parseInt(penguin.style.top) || restPosition.y
            };
            
            // Show slingshot bands
            slingshotBandLeft.style.display = 'block';
            slingshotBandRight.style.display = 'block';
            
            // Show and position touch marker
            const touchX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            const touchY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            updateTouchMarker(touchX, touchY);
            
            // Initialize the drag distance
            const slingshotRect = slingshot.getBoundingClientRect();
            const slingshotCenterX = slingshotRect.left + slingshotRect.width / 2;
            const slingshotTopY = slingshotRect.top;
            
            window.lastDragDistance = {
                x: touchX - slingshotCenterX,
                y: touchY - slingshotTopY
            };
            
            // Add event listeners for movement only
            // Release events are handled by global event listeners
            document.addEventListener('mousemove', onDrag, { passive: false });
            document.addEventListener('touchmove', onDrag, { passive: false });
            
            console.log("Event listeners added");
        }
        
        function onDrag(e) {
            e.preventDefault();
            
            if (!isDragging) return;
            
            // Get drag position based on event type
            const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            
            // Update touch marker position
            updateTouchMarker(clientX, clientY);
            
            // Calculate new position
            const slingshotRect = slingshot.getBoundingClientRect();
            const slingshotCenterX = slingshotRect.left + slingshotRect.width / 2;
            const slingshotTopY = slingshotRect.top;
            
            // Limit drag distance for reasonable gameplay
            const dragDistance = {
                x: clientX - slingshotCenterX,
                y: clientY - slingshotTopY
            };
            
            // Calculate magnitude of drag
            const magnitude = Math.sqrt(dragDistance.x * dragDistance.x + dragDistance.y * dragDistance.y);
            const maxMagnitude = 150; // Maximum drag distance
            
            // Limit the drag to be mostly to the left and down from the slingshot
            // This ensures proper slingshot behavior
            if (dragDistance.x > 50) { // Limit rightward drag
                dragDistance.x = 50;
            }
            
            if (magnitude > maxMagnitude) {
                dragDistance.x = (dragDistance.x / magnitude) * maxMagnitude;
                dragDistance.y = (dragDistance.y / magnitude) * maxMagnitude;
            }
            
            // Calculate new penguin position
            currentPos = {
                x: slingshotCenterX + dragDistance.x - PENGUIN_RADIUS,
                y: slingshotTopY + dragDistance.y - PENGUIN_RADIUS
            };
            
            // Update penguin position
            penguin.style.left = `${currentPos.x}px`;
            penguin.style.top = `${currentPos.y}px`;
            
            // Update slingshot bands
            updateSlingshotBands(currentPos.x + PENGUIN_RADIUS, currentPos.y + PENGUIN_RADIUS);
            
            // Store the drag distance for use in endDrag
            window.lastDragDistance = dragDistance;
        }
        
        function updateSlingshotBands(penguinX, penguinY) {
            const slingshotRect = slingshot.getBoundingClientRect();
            const slingshotTopCenterX = slingshotRect.left + slingshotRect.width / 2;
            const slingshotTopY = slingshotRect.top;
            
            // Calculate distances for the left band
            const leftBandStartX = slingshotRect.left;
            const leftBandStartY = slingshotTopY;
            const leftDx = penguinX - leftBandStartX;
            const leftDy = penguinY - leftBandStartY;
            const leftLength = Math.sqrt(leftDx * leftDx + leftDy * leftDy);
            const leftAngle = Math.atan2(leftDy, leftDx) - Math.PI/2;
            
            // Calculate distances for the right band
            const rightBandStartX = slingshotRect.right;
            const rightBandStartY = slingshotTopY;
            const rightDx = penguinX - rightBandStartX;
            const rightDy = penguinY - rightBandStartY;
            const rightLength = Math.sqrt(rightDx * rightDx + rightDy * rightDy);
            const rightAngle = Math.atan2(rightDy, rightDx) - Math.PI/2;
            
            // Update left band
            slingshotBandLeft.style.height = `${leftLength}px`;
            slingshotBandLeft.style.transform = `rotate(${leftAngle}rad)`;
            slingshotBandLeft.style.left = `0px`;
            slingshotBandLeft.style.transformOrigin = '0 0';
            
            // Update right band
            slingshotBandRight.style.height = `${rightLength}px`;
            slingshotBandRight.style.transform = `rotate(${rightAngle}rad)`;
            slingshotBandRight.style.right = `0px`;
            slingshotBandRight.style.transformOrigin = '100% 0';
        }
        
        function endDrag(e) {
            if (!isDragging) return;
            
            console.log("endDrag called");
            debugger;
            
            isDragging = false;
            
            // Hide touch marker
            touchMarker.style.display = 'none';
            
            // Remove event listeners for movement only
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('touchmove', onDrag);
            
            // Calculate velocity based on drag distance
            const slingshotRect = slingshot.getBoundingClientRect();
            const slingshotCenterX = slingshotRect.left + slingshotRect.width / 2;
            const slingshotTopY = slingshotRect.top;
            
            // Use the stored drag distance if available, otherwise calculate it
            let dragDistance;
            if (window.lastDragDistance) {
                dragDistance = window.lastDragDistance;
                console.log("Using stored drag distance:", dragDistance);
            } else {
                dragDistance = {
                    x: currentPos.x + PENGUIN_RADIUS - slingshotCenterX,
                    y: currentPos.y + PENGUIN_RADIUS - slingshotTopY
                };
                console.log("Calculated drag distance:", dragDistance);
            }
            
            console.log("Drag distance:", dragDistance);
            
            // Launch penguin in the opposite direction of drag with proper physics
            // The further you pull, the more power you get
            const pullDistance = Math.sqrt(dragDistance.x * dragDistance.x + dragDistance.y * dragDistance.y);
            
            console.log("Pull distance:", pullDistance);
            
            // Only launch if the pull distance is significant enough
            if (pullDistance < 5) {
                // Pull distance too small, reset penguin without launching
                console.log("Launch canceled: Pull distance too small");
                resetPenguin();
                return;
            }
            
            const powerFactor = Math.min(pullDistance / 50, 3); // Cap the power factor
            
            velocity = {
                x: -dragDistance.x / ELASTICITY * powerFactor,
                y: -dragDistance.y / ELASTICITY * powerFactor
            };
            
            console.log("Initial velocity:", velocity);
            
            // Ensure minimum launch velocity
            const minLaunchSpeed = 3;
            const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
            
            if (currentSpeed < minLaunchSpeed) {
                // Scale up velocity to ensure minimum launch speed
                const scaleFactor = minLaunchSpeed / currentSpeed;
                velocity.x *= scaleFactor;
                velocity.y *= scaleFactor;
                
                console.log("Velocity boosted:", velocity);
            }
            
            // Hide slingshot bands
            slingshotBandLeft.style.display = 'none';
            slingshotBandRight.style.display = 'none';
            
            // Start physics simulation
            isPenguinLaunched = true;
            penguinLastTimestamp = performance.now(); // Use penguin-specific timestamp
            animationFrameId = requestAnimationFrame(updatePhysics);
            
            console.log("Physics simulation started, t=" + penguinLastTimestamp);
            
            // Clear the stored drag distance
            window.lastDragDistance = null;
        }
        
        function updatePhysics(timestamp) {
            // Don't update if game is paused
            if (gamePaused) {
                animationFrameId = requestAnimationFrame(updatePhysics);
                return;
            }
            
            console.log("updatePhysics called t=" + timestamp + "; penguinLastTimestamp=" + penguinLastTimestamp);
            
            // Calculate elapsed time
            const deltaTime = timestamp - penguinLastTimestamp;
            penguinLastTimestamp = timestamp;

            debugger;
            
            // Scale time factor to keep physics consistent regardless of frame rate
            const timeScale = deltaTime / 16; // Normalized to 60fps
            
            // Update position based on velocity
            const newX = currentPos.x + velocity.x * timeScale;
            const newY = currentPos.y + velocity.y * timeScale;
            
            console.log("New position:", { x: newX, y: newY });
            console.log("Current velocity:", velocity);
            
            // Check for collision with ground
            const gameRect = document.getElementById('game-area').getBoundingClientRect();
            const groundY = gameRect.height * 0.8; // 80% of game area height (ground starts at 20% from bottom)
            
            // Get slingshot position to determine if we should apply left wall collision
            const slingshotRect = slingshot.getBoundingClientRect();
            const slingshotX = slingshotRect.left;
            
            // Check for wall collisions
            if (newX < 0 && slingshotX < newX) {
                // Left wall collision - only apply if penguin is to the right of the slingshot
                velocity.x = -velocity.x * BOUNCE_FACTOR;
                // Ensure a minimum bounce velocity to prevent getting stuck
                if (Math.abs(velocity.x) < 2) {
                    velocity.x = 2; // Minimum rightward velocity after left wall collision
                }
                currentPos.x = 0;
            } else if (newX + PENGUIN_RADIUS * 2 > gameRect.width) {
                // Right wall collision
                velocity.x = -velocity.x * BOUNCE_FACTOR;
                // Ensure a minimum bounce velocity to prevent getting stuck
                if (Math.abs(velocity.x) < 2) {
                    velocity.x = -2; // Minimum leftward velocity after right wall collision
                }
                currentPos.x = gameRect.width - PENGUIN_RADIUS * 2;
            } else {
                currentPos.x = newX;
            }
            
            // Check for ground collision, but only if we're not in gameEnding mode
            // During gameEnding, let the penguin fall through the ground
            if (newY + PENGUIN_RADIUS * 2 > groundY && !gameEnding) {
                // Ground collision
                velocity.y = -velocity.y * BOUNCE_FACTOR;
                currentPos.y = groundY - PENGUIN_RADIUS * 2;
                
                // Apply extra friction when hitting the ground
                velocity.x *= FRICTION;
            } else {
                currentPos.y = newY;
                // Apply gravity - increase gravity when game is ending for a faster fall
                velocity.y += gameEnding ? GRAVITY * 1.5 * timeScale : GRAVITY * timeScale;
            }
            
            // Apply friction to slow down the penguin
            velocity.x *= FRICTION;
            
            // Update penguin position
            penguin.style.left = `${currentPos.x}px`;
            penguin.style.top = `${currentPos.y}px`;
            
            // If game is ending, make sure penguin is visible above the overlay
            if (gameEnding) {
                penguin.style.zIndex = "101";
                // Add a trail effect during game ending for more visual impact
                createFallingTrail(currentPos.x + PENGUIN_RADIUS, currentPos.y + PENGUIN_RADIUS);
            } else {
                penguin.style.zIndex = "3"; // Reset to original z-index
            }
            
            const penguinEmoji = penguin.querySelector('.js-penguin-emoji');
            
            // Update penguin facing direction based on velocity
            const previousFacingRight = penguinEmoji.classList.contains('face-right');
            
            if (velocity.x === 0) {
                penguinEmoji.classList.add('face-right');
            } else if (velocity.x > 0.5) {
                penguinEmoji.classList.add('face-right');
            } else if (velocity.x < -0.5) {
                penguinEmoji.classList.remove('face-right');
            }
            
            // Update favicon if direction changed
            const currentFacingRight = penguinEmoji.classList.contains('face-right');
            if (previousFacingRight !== currentFacingRight) {
                updateFaviconDirection();
            }
            
            // Check for collisions with enemies
            const penguinCenterX = currentPos.x + PENGUIN_RADIUS;
            const penguinCenterY = currentPos.y + PENGUIN_RADIUS;
            
            enemies.forEach(enemy => {
                if (!enemy.isHit) {
                    const enemyRect = enemy.element.getBoundingClientRect();
                    const enemyCenterX = enemyRect.left + enemyRect.width / 2;
                    const enemyCenterY = enemyRect.top + enemyRect.height / 2;
                    
                    // Calculate distance between penguin and enemy
                    const dx = penguinCenterX - enemyCenterX;
                    const dy = penguinCenterY - enemyCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate the effective enemy radius based on its size
                    const effectiveEnemyRadius = ENEMY_RADIUS * enemy.size;
                    
                    // Check for collision with adjusted radius
                    if (distance < PENGUIN_RADIUS + effectiveEnemyRadius) {
                        // Calculate current speed
                        const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
                        
                        // Determine if the penguin is moving fast enough to destroy the enemy
                        if (currentSpeed >= MIN_EXPLOSION_SPEED) {
                            // Mark enemy as hit
                            enemy.isHit = true;
                            
                            // Create explosion effects at the enemy's position
                            createExplosionEffect(enemyCenterX, enemyCenterY);
                            
                            // Hide the enemy
                            enemy.element.style.opacity = '0';
                            
                            // Update score
                            score += enemy.points;
                            document.getElementById('score').textContent = score;
                        } else {
                            // Not fast enough for explosion - just bounce off
                            handleLowVelocityCollision(enemy, dx, dy, distance);
                        }
                        
                        // Add some bounce effect when hitting an enemy
                        const bounceDirection = {
                            x: dx / distance,
                            y: dy / distance
                        };
                        
                        velocity.x += bounceDirection.x * 2;
                        velocity.y += bounceDirection.y * 2;
                    }
                }
            });
            
            // Stop animation if penguin is almost stopped
            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
            
            // Only stop the penguin if it has actually stopped on the ground
            const penguinHasStopped = (speed < 0.5 && Math.abs(velocity.y) < 0.5 && currentPos.y + PENGUIN_RADIUS * 2 >= groundY - 1);
            
            // Check if penguin is moving very slowly but not completely stopped
            const isMovingSlowly = (speed < 1.5 && !penguinHasStopped);
            
            // Check if penguin is barely moving at all (almost static)
            const isAlmostStatic = (speed < 0.2);
            
            // If penguin is almost static and not on the ground, force a reset
            if (isAlmostStatic && currentPos.y + PENGUIN_RADIUS * 2 < groundY - 5) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                if (debugMode) {
                    console.log("Penguin reset: Almost static in mid-air");
                }
                resetPenguin();
                slowMovementTime = 0;
                return;
            }
            
            if (isMovingSlowly) {
                // Increment the slow movement timer
                slowMovementTime += deltaTime;
                
                // If penguin has been moving slowly for too long, reset it
                if (slowMovementTime > MAX_SLOW_MOVEMENT_TIME) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    if (debugMode) {
                        console.log("Penguin reset: Moving slowly for too long");
                    }
                    resetPenguin();
                    slowMovementTime = 0;
                    return;
                }
            } else {
                // Reset the slow movement timer if penguin is moving normally
                slowMovementTime = 0;
            }
            
            if (penguinHasStopped) {
                // Penguin has stopped on the ground
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                
                // Reset penguin for next launch
                setTimeout(() => {
                    resetPenguin();
                }, 100); // Changed from 500ms to 100ms for faster reloading
            } else {
                // Continue animation
                animationFrameId = requestAnimationFrame(updatePhysics);
            }
        }
        
        function switchToNextEnemy() {
            // Decrement enemies remaining
            enemiesInWave--;
            
            if (enemiesInWave > 0) {
                // Move the waiting enemy to the slingshot
                waitingPenguin.classList.remove('jumping');
                
                // Animate the waiting enemy moving to the slingshot
                const slingshotRect = slingshot.getBoundingClientRect();
                const waitingEnemyRect = waitingPenguin.getBoundingClientRect();
                
                // Get the current enemy emoji from the waiting penguin
                const waitingEnemySpan = waitingPenguin.querySelector('span');
                const currentEnemyEmoji = waitingEnemySpan ? waitingEnemySpan.textContent : TARGET_TYPES[0].emoji;
                
                // Create a clone of the waiting enemy for animation
                const enemyClone = document.createElement('div');
                enemyClone.id = 'enemy-clone';
                enemyClone.style.position = 'absolute';
                enemyClone.style.left = `${waitingEnemyRect.left}px`;
                enemyClone.style.top = `${waitingEnemyRect.top}px`;
                enemyClone.style.transition = 'all 0.5s ease-in-out';
                enemyClone.style.zIndex = '5';
                enemyClone.style.fontSize = '35px';
                
                // Add the enemy emoji with face-right class
                const enemySpan = document.createElement('span');
                enemySpan.style.transform = 'scaleX(-1)';
                enemySpan.style.display = 'inline-block';
                enemySpan.textContent = currentEnemyEmoji;
                enemyClone.appendChild(enemySpan);
                
                document.getElementById('game-area').appendChild(enemyClone);
                
                // Hide the original waiting enemy
                waitingPenguin.style.opacity = '0';
                
                // Animate the clone to the slingshot position
                setTimeout(() => {
                    enemyClone.style.left = `${restPosition.x}px`;
                    enemyClone.style.top = `${restPosition.y}px`;
                }, 50);
                
                // After animation completes, reset the enemy
                setTimeout(() => {
                    // Remove the clone
                    if (enemyClone.parentNode) {
                        enemyClone.parentNode.removeChild(enemyClone);
                    }
                    
                    // Reset the main enemy
                    resetPenguin();
                    
                    // Hide the waiting enemy (it's now in the slingshot)
                    waitingPenguin.style.display = 'none';
                }, 300); // Reduced from 600ms to 300ms for faster transitions
                
                // Select a new random enemy for the next waiting penguin
                const randomEnemyType = TARGET_TYPES[Math.floor(Math.random() * TARGET_TYPES.length)];
                const penguinEmoji = penguin.querySelector('.js-penguin-emoji');
                penguinEmoji.textContent = currentEnemyEmoji;
            } else {
                // No more enemies - check if all enemies are hit
                const allEnemiesHit = enemies.every(enemy => enemy.isHit);
                if (!allEnemiesHit) {
                    // Not all enemies hit - game over
                    showGameOver("Game Over!");
                }
            }
        }
        
        function showGameOver(message) {
            // Ensure game is unpaused when showing game over
            gamePaused = false;
            document.getElementById('pause-overlay').style.display = 'none';
            
            // For the last enemy, add a delay before stopping the animation
            if (enemiesInWave === 0 && message === "Game Over!") {
                // Show the game over screen immediately
                displayGameOverScreen(message);
                
                // But continue the animation for a while to let the enemy fall
                setTimeout(() => {
                    // Now cancel the animation frame if it's still running
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    // Clear game animation as well
                    if (gameAnimationFrameId) {
                        cancelAnimationFrame(gameAnimationFrameId);
                        gameAnimationFrameId = null;
                    }
                    // Reset the gameEnding flag
                    gameEnding = false;
                }, 2500);
            } else {
                // No animation continuation for win or other scenarios
                displayGameOverScreen(message);
                
                // Cancel both animations
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                if (gameAnimationFrameId) {
                    cancelAnimationFrame(gameAnimationFrameId);
                    gameAnimationFrameId = null;
                }
            }
        }
        
        function displayGameOverScreen(message) {
            // Update the game over overlay
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const gameOverContent = document.getElementById('game-over-content');
            const finalScore = document.getElementById('final-score');
            const finalWave = document.getElementById('final-wave');
            
            // Set the message and score
            gameOverContent.querySelector('h1').textContent = message;
            finalScore.textContent = score;
            finalWave.textContent = currentWave;
            
            // Show the overlay with some transparency to see the enemy falling
            if (gameEnding) {
                gameOverOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // More transparent
            } else {
                gameOverOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)'; // Original opacity
            }
            
            // Show the overlay
            gameOverOverlay.style.display = 'flex';
            
            // Set game over flag
            gameOver = true;
        }
        
        function resetPositions() {
            // Recalculate positions for all game elements
            const gameArea = document.getElementById('game-area');
            const gameRect = gameArea.getBoundingClientRect();
            
            // Reset penguin position
            const slingshotRect = slingshot.getBoundingClientRect();
            restPosition = {
                x: slingshotRect.left + (slingshotRect.width / 2) - (penguin.offsetWidth / 2),
                y: slingshotRect.top - penguin.offsetHeight + 10
            };
            
            // Only update penguin position if it's not launched
            if (!isPenguinLaunched) {
                penguin.style.left = `${restPosition.x}px`;
                penguin.style.top = `${restPosition.y}px`;
                currentPos = { x: restPosition.x, y: restPosition.y };
            }
            
            // Reposition enemies based on new window size
            const groundHeight = gameRect.height * 0.20;
            const availableHeight = gameRect.height - groundHeight;
            
            enemies.forEach((enemy, index) => {
                if (!enemy.isHit) {
                    // Calculate new positions based on relative positions
                    let newX, newY;
                    
                    switch(index % 5) {
                        case 0:
                            newX = gameRect.width * 0.6;
                            newY = availableHeight * 0.8;
                            break;
                        case 1:
                            newX = gameRect.width * 0.7;
                            newY = availableHeight * 0.7;
                            break;
                        case 2:
                            newX = gameRect.width * 0.8;
                            newY = availableHeight * 0.9;
                            break;
                        case 3:
                            newX = gameRect.width * 0.7;
                            newY = availableHeight * 0.5;
                            break;
                        case 4:
                            newX = gameRect.width * 0.85;
                            newY = availableHeight * 0.6;
                            break;
                    }
                    
                    // Update enemy position
                    enemy.element.style.left = `${newX}px`;
                    enemy.element.style.top = `${newY}px`;
                    enemy.position = { x: newX, y: newY };
                }
            });
        }
        
        function resetPenguin() {
            // Recalculate the slingshot position every time we reset
            // This ensures the enemy is always positioned correctly
            const slingshotRect = slingshot.getBoundingClientRect();
            restPosition = {
                x: slingshotRect.left + (slingshotRect.width / 2) - (penguin.offsetWidth / 2),
                y: slingshotRect.top - penguin.offsetHeight + 10 // Add a small overlap
            };
            
            // Reset enemy position to the slingshot
            penguin.style.left = `${restPosition.x}px`;
            penguin.style.top = `${restPosition.y}px`;
            
            // Reset physics variables
            currentPos = { x: restPosition.x, y: restPosition.y };
            velocity = { x: 0, y: 0 };
            isPenguinLaunched = false;
            slowMovementTime = 0; // Reset slow movement timer
            
            // Clear any stored drag distance
            window.lastDragDistance = null;
            
            const penguinEmoji = penguin.querySelector('.js-penguin-emoji');
            // Make sure enemy is facing right at reset
            penguinEmoji.classList.add('face-right');
            
            // Add animation to the enemy in the slingshot
            penguin.classList.add('slingshot-penguin-animate');
            
            // Update favicon to match enemy direction
            updateFaviconDirection();
            
            // Hide slingshot bands and touch marker
            slingshotBandLeft.style.display = 'none';
            slingshotBandRight.style.display = 'none';
            touchMarker.style.display = 'none';
            
            // Cancel any ongoing penguin animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        function restartGame() {
            // Hide game over overlay and ensure game is unpaused
            document.getElementById('game-over-overlay').style.display = 'none';
            document.getElementById('pause-overlay').style.display = 'none';
            gamePaused = false;
            
            // Cancel any ongoing animations
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (gameAnimationFrameId) {
                cancelAnimationFrame(gameAnimationFrameId);
                gameAnimationFrameId = null;
            }
            
            // Reset enemy
            resetPenguin();
            
            // Reset waiting enemy
            waitingPenguin.style.display = 'block';
            waitingPenguin.style.opacity = '1';
            waitingPenguin.classList.add('jumping');
            
            // Make sure the waiting enemy's span has the correct transform
            const waitingEnemyDiv = waitingPenguin.querySelector('span');
            // Select a random water-related enemy
            const randomEnemyType = TARGET_TYPES[Math.floor(Math.random() * TARGET_TYPES.length)];
            
            if (waitingEnemyDiv) {
                waitingEnemyDiv.style.transform = 'scaleX(-1)';
                waitingEnemyDiv.style.display = 'inline-block';
                waitingEnemyDiv.textContent = randomEnemyType.emoji;
            } else {
                // If the span doesn't exist for some reason, recreate it
                waitingPenguin.innerHTML = `<span style="transform: scaleX(-1); display: inline-block;">${randomEnemyType.emoji}</span>`;
            }
            
            applyRandomJumpDelay();
            
            // Reset level to 1 when restarting the game
            currentLevel = 1;
            
            // Create new enemies
            createEnemies();
            
            // Reset score and enemies
            score = 0;
            enemiesInWave = 7;
            gameOver = false;
            gameEnding = false;
            document.getElementById('score').textContent = score;
        }
        
        function toggleDebug() {
            const debugPanel = document.getElementById('debug-panel');
            const debugButton = document.getElementById('debug-toggle');
            
            debugMode = !debugMode;
            
            if (debugMode) {
                debugPanel.style.display = 'block';
                debugButton.textContent = 'Hide Debug';
            } else {
                debugPanel.style.display = 'none';
                debugButton.textContent = 'Show Debug';
            }
        }
        
        function updateDebugInfo() {
            if (debugMode) {
                const debugPanel = document.getElementById('debug-panel');
                const gameRect = document.getElementById('game-area').getBoundingClientRect();
                const penguinRect = penguin.getBoundingClientRect();
                
                const debugInfo = `
                    Viewport: ${window.innerWidth}x${window.innerHeight}<br>
                    Game Area: ${gameRect.width.toFixed(0)}x${gameRect.height.toFixed(0)}<br>
                    Penguin Pos: (${currentPos.x.toFixed(1)}, ${currentPos.y.toFixed(1)})<br>
                    Velocity: (${velocity.x.toFixed(2)}, ${velocity.y.toFixed(2)})<br>
                    Penguin State: ${isPenguinLaunched ? 'Launched' : 'Ready'}<br>
                    Enemies Left: ${enemiesInWave}/${enemies.length}<br>
                    Current Level: ${currentLevel} (${DIFFICULTY_LEVELS[currentDifficulty].name})<br>
                    Touch Position: (${touchMarker.style.left}, ${touchMarker.style.top})
                `;
                
                debugPanel.innerHTML = debugInfo;
            }
            
            requestAnimationFrame(updateDebugInfo);
        }
        
        // Function to update touch marker position
        function updateTouchMarker(x, y) {
            // Only show touch marker if debug mode is active
            touchMarker.style.display = debugMode ? 'block' : 'none';
            touchMarker.style.left = `${x}px`;
            touchMarker.style.top = `${y}px`;
        }
        
        // Function to create multiple explosions for a more dramatic effect
        function createExplosionEffect(x, y) {
            // Create 3-5 explosions at slightly different positions
            const numExplosions = Math.floor(Math.random() * 3) + 3;
            
            // Play explosion sound
            const soundIndex = Math.random() > 0.5 ? 1 : 2;
            const explosionSound = document.getElementById(`explosion-sound-${soundIndex}`);
            if (explosionSound) {
                explosionSound.currentTime = 0;
                explosionSound.play().catch(e => console.log("Audio play failed:", e));
            }
            
            // Add shake effect to game area
            const gameArea = document.getElementById('game-area');
            gameArea.classList.add('shake');
            
            // Remove shake class after animation completes
            setTimeout(() => {
                gameArea.classList.remove('shake');
            }, 500);
            
            // Mark explosion as active in favicon
            document.getElementById('favicon').dataset.explosionActive = 'true';
            
            // Update favicon to explosion
            setFavicon('explosion');
            
            // Reset favicon to enemy after a delay
            setTimeout(() => {
                document.getElementById('favicon').dataset.explosionActive = 'false';
                updateFaviconDirection();
            }, 1000);
            
            for (let i = 0; i < numExplosions; i++) {
                // Random offset from the center - increased for larger targets
                const offsetX = (Math.random() - 0.5) * 60;
                const offsetY = (Math.random() - 0.5) * 60;
                
                // Random size variation - increased for larger targets
                const size = 52.5 + Math.random() * 45;
                
                // Random delay for each explosion
                const delay = Math.random() * 200;
                
                // Random rotation
                const rotation = (Math.random() - 0.5) * 40;
                
                // Create explosion element
                const explosion = document.createElement('div');
                explosion.className = 'explosion';
                explosion.textContent = 'üí•';
                explosion.style.fontSize = `${size}px`;
                explosion.style.left = `${x + offsetX - size/2}px`;
                explosion.style.top = `${y + offsetY - size/2}px`;
                document.getElementById('game-area').appendChild(explosion);
                
                // Trigger explosion animation with delay
                setTimeout(() => {
                    explosion.classList.add('active');
                    explosion.style.transform = `scale(2.0) rotate(${rotation}deg)`;
                }, delay);
                
                // Remove explosion after animation completes
                setTimeout(() => {
                    if (explosion.parentNode) {
                        explosion.parentNode.removeChild(explosion);
                    }
                }, delay + 600);
            }
        }
        
        // Function to apply a random animation delay to the waiting enemy
        function applyRandomJumpDelay() {
            // Apply a random animation delay to make the jumping more natural
            const randomDelay = Math.random() * 1; // Random delay between 0 and 4 seconds
            waitingPenguin.style.animationDelay = `${randomDelay}s`;
            
            // Also apply a random animation duration for even more variation
            const randomDuration = 3.5 + Math.random(); // Random duration between 3.5 and 4.5 seconds
            waitingPenguin.style.animationDuration = `${randomDuration}s`;
        }
        
        // Function to create a trail effect for the falling enemy
        function createFallingTrail(x, y) {
            // Only create a trail occasionally
            if (Math.random() > 0.2) return;
            
            // Create a small particle
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.width = '8px';
            particle.style.height = '8px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            particle.style.zIndex = '100';
            particle.style.transition = 'all 0.8s ease-out';
            
            document.getElementById('game-area').appendChild(particle);
            
            // Animate the particle
            setTimeout(() => {
                particle.style.transform = `translate(${(Math.random() - 0.5) * 30}px, ${Math.random() * 50}px)`;
                particle.style.opacity = '0';
            }, 10);
            
            // Remove the particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 800);
        }
        
        // Function to handle low velocity collisions with enemies
        function handleLowVelocityCollision(enemy, dx, dy, distance) {
            // Calculate bounce direction
            const bounceDirection = {
                x: dx / distance,
                y: dy / distance
            };
            
            // Apply a bounce effect proportional to the enemy's size
            // Larger enemies cause stronger bounces
            const bounceForce = 3 * enemy.size;
            
            // Apply the bounce effect
            velocity.x += bounceDirection.x * bounceForce;
            velocity.y += bounceDirection.y * bounceForce;
            
            // Make the enemy wobble a bit, with wobble amount proportional to size
            const wobbleAmount = (Math.random() - 0.5) * 20;
            const scaleAmount = 1.1 * enemy.size;
            enemy.element.style.transition = 'transform 0.3s ease-in-out';
            enemy.element.style.transform = `rotate(${wobbleAmount}deg) scale(${scaleAmount})`;
            
            // Reset the enemy's transform after the wobble
            setTimeout(() => {
                enemy.element.style.transform = 'rotate(0deg) scale(1)';
            }, 300);
        }
        
        function startNextWave() {
            // Increment wave counter
            if (waveInProgress || gameOver) {
                return; // Don't start a new wave if one is already in progress
            }
            
            // Update wave display
            document.getElementById('wave-number').textContent = currentWave;
            
            // Calculate number of enemies for this wave - increased from 5 to 7 base enemies
            enemiesInWave = 7 + Math.floor(currentWave / 1.5); // Increase enemies as waves progress
            
            // Calculate enemy speed for this wave - increased base speed from 0.5 to 0.7
            enemySpeed = 0.7 + (currentWave * 0.12); // Increase speed as waves progress
            
            // Set wave in progress flag
            waveInProgress = true;
            
            // Start spawning enemies
            spawnEnemyWave();
            
            // Start the game animation loop if it's not already running
            if (!gameAnimationFrameId) {
                gameLastTimestamp = performance.now();
                gameAnimationFrameId = requestAnimationFrame(updateGame);
            }
        }
        
        function spawnEnemyWave() {
            // Clear any existing spawn intervals
            if (enemySpawnInterval) {
                clearInterval(enemySpawnInterval);
            }
            
            // Calculate spawn delay based on wave (faster spawns in later waves)
            // Reduced base delay from 800ms to 500ms for more frequent spawns
            const spawnDelay = Math.max(200, 500 - (currentWave * 50));
            
            let enemiesSpawned = 0;
            
            // Set up interval to spawn enemies
            enemySpawnInterval = setInterval(() => {
                if (enemiesSpawned < enemiesInWave && !gameOver) {
                    spawnEnemy();
                    enemiesSpawned++;
                } else {
                    // All enemies spawned or game over
                    clearInterval(enemySpawnInterval);
                    enemySpawnInterval = null;
                    
                    // Check if wave is complete
                    checkWaveComplete();
                }
            }, spawnDelay);
        }
        
        function spawnEnemy() {
            const gameArea = document.getElementById('game-area');
            const gameRect = gameArea.getBoundingClientRect();
            
            // Create enemy element
            const enemyElement = document.createElement('div');
            enemyElement.className = 'enemy';
            
            // Randomly select an enemy type from the TARGET_TYPES array
            const enemyTypeIndex = Math.floor(Math.random() * TARGET_TYPES.length);
            const enemyType = TARGET_TYPES[enemyTypeIndex];
            
            // Set the emoji content
            enemyElement.textContent = enemyType.emoji;
            
            // Apply more dramatic size variation (¬±50% of the base size)
            const sizeVariation = 0.5 + (Math.random() * 1.0); // 0.5 to 1.5
            const finalSize = enemyType.size * sizeVariation;
            
            // Apply the size to the element
            enemyElement.style.fontSize = `${35 * finalSize}px`;
            
            // Set initial position - start from right side of screen
            const x = gameRect.width;
            // Random y position above the ground but below the top
            const groundHeight = gameRect.height * 0.20;
            const y = groundHeight + Math.random() * (gameRect.height * 0.6);
            
            enemyElement.style.left = `${x}px`;
            enemyElement.style.top = `${y}px`;
            
            // Add to game area
            gameArea.appendChild(enemyElement);
            
            // Add to enemies array
            enemies.push({
                element: enemyElement,
                position: { x, y },
                speed: enemySpeed * (0.7 + Math.random() * 0.6), // More speed variation (0.7 to 1.3)
                isHit: false,
                type: enemyType.emoji,
                points: enemyType.points,
                size: finalSize // Store the size for collision detection
            });
            
            // Start animation loop if not already running
            if (!gameAnimationFrameId && !isPenguinLaunched) {
                gameLastTimestamp = performance.now();
                gameAnimationFrameId = requestAnimationFrame(updateGame);
            }
        }
        
        function updateGame(timestamp) {
            // Don't update if game is paused
            if (gamePaused) {
                gameAnimationFrameId = requestAnimationFrame(updateGame);
                return;
            }
            
            // Calculate elapsed time
            const deltaTime = timestamp - gameLastTimestamp;
            gameLastTimestamp = timestamp;
            
            // Scale time factor to keep physics consistent regardless of frame rate
            const timeScale = deltaTime / 16; // Normalized to 60fps
            
            // Update enemy positions
            updateEnemies(timeScale);
            
            // Check for base collisions
            checkBaseCollisions();
            
            // Continue animation
            gameAnimationFrameId = requestAnimationFrame(updateGame);
        }
        
        function updateEnemies(timeScale) {
            const gameRect = document.getElementById('game-area').getBoundingClientRect();
            const baseRect = document.getElementById('base').getBoundingClientRect();
            
            enemies.forEach(enemy => {
                if (!enemy.isHit) {
                    // Move enemy from right to left
                    enemy.position.x -= enemy.speed * timeScale;
                    
                    // Update enemy position
                    enemy.element.style.left = `${enemy.position.x}px`;
                    
                    // Check if enemy has reached the base
                    if (enemy.position.x <= baseRect.right) {
                        // Enemy reached the base - mark as hit and damage base
                        enemy.isHit = true;
                        enemy.element.style.opacity = '0';
                        
                        // Damage the base
                        damageBase(BASE_DAMAGE_PER_ENEMY);
                        
                        // Create explosion at base edge
                        createExplosionEffect(baseRect.right, enemy.position.y);
                    }
                    
                    // Check if enemy is off screen to the left
                    if (enemy.position.x < -50) {
                        enemy.isHit = true;
                        enemy.element.style.display = 'none';
                    }
                }
            });
            
            // Check if wave is complete
            checkWaveComplete();
        }
        
        function checkBaseCollisions() {
            // This function is called by updateGame to check if enemies have reached the base
            // The actual collision detection is done in updateEnemies
        }
        
        function damageBase(damage) {
            // Reduce base health
            baseHealth = Math.max(0, baseHealth - damage);
            
            // Update health bar
            const healthBar = document.getElementById('health-bar');
            healthBar.style.width = `${baseHealth}%`;
            
            // Change color based on health
            if (baseHealth < 25) {
                healthBar.style.backgroundColor = '#FF4500'; // Red
            } else if (baseHealth < 50) {
                healthBar.style.backgroundColor = '#FFA500'; // Orange
            }
            
            // Add damage animation to base
            const base = document.getElementById('base');
            base.classList.add('base-damage');
            
            // Remove animation class after it completes
            setTimeout(() => {
                base.classList.remove('base-damage');
            }, 500);
            
            // Check if base is destroyed
            if (baseHealth <= 0) {
                // Game over - base destroyed
                showGameOver("Base Destroyed!");
            }
        }
        
        function checkWaveComplete() {
            // Check if all enemies are hit or off screen
            const allEnemiesProcessed = enemies.every(enemy => enemy.isHit);
            
            // If all enemies are processed and no more spawning, wave is complete
            if (allEnemiesProcessed && !enemySpawnInterval && waveInProgress) {
                waveInProgress = false;
                
                // Start next wave after delay
                setTimeout(() => {
                    currentWave++;
                    
                    // Update wave display with animation
                    const waveContainer = document.getElementById('wave-container');
                    document.getElementById('wave-number').textContent = currentWave;
                    waveContainer.classList.add('wave-transition');
                    
                    // Remove animation class after it completes
                    setTimeout(() => {
                        waveContainer.classList.remove('wave-transition');
                    }, 1000);
                    
                    // Start the next wave
                    startNextWave();
                }, 3000);
            }
        }
        
        function pauseGame() {
            if (gameOver) return; // Don't pause if game is already over
            
            gamePaused = true;
            document.getElementById('pause-overlay').style.display = 'flex';
            
            // When pausing, we keep the animation loops running but they effectively do nothing
            // This makes it easy to resume without having to manually restart the loops
        }
        
        function resumeGame() {
            gamePaused = false;
            document.getElementById('pause-overlay').style.display = 'none';
            
            // Update timestamps to prevent large time jumps when resuming
            if (animationFrameId) {
                penguinLastTimestamp = performance.now();
            }
            if (gameAnimationFrameId) {
                gameLastTimestamp = performance.now();
            }
        }
    </script>
</body>
</html>